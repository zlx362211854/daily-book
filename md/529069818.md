
 # 84.V8 引擎如何进行垃圾内存的回收 
  
 ***
## o1wish 
 > commented 23 days ago 

首先，JS 中复杂类型数据是存储在堆内存的，而 V8 在 64 位操作系统中能使用的堆内存空间约为 1.4G，这一方面是由于 V8 是单线程机制，另一方面就是它的垃圾回收机制。

V8 使用了代垃圾回收器，其中的堆内存划分为新生代和老生代：
![image](https://user-images.githubusercontent.com/43943810/69719872-60f3d280-114c-11ea-8580-fb5f11a3300c.png)
而新生代则采用半空间策略，其中新对象最初是在新生代的活动半空间中分配的（ From ），一旦该半空间变满，清除操作会将活动对象移动到另一半空间（ To ），再对 From 空间执行清除操作，之后交换 From 空间和 To 空间，当 To 空间使用超过新生代内存的 25% 时，那些经过多次清除依然活跃的对象则被标记为长期存活，移动到老生代内存空间。

当老生代空间的使用率超过一定限制时，则会触发一轮垃圾回收，那些没有被根（ 这里理解为 window ）引用的对象会被添加标记然后清除掉，这就是所谓的 **标记-清除** ，但这样就出现了弊端，一组占用连续内存空间的对象经过清除后使得本身连续的内存变得残缺，这被称之为 **内存碎片**，那这又有什么缺陷呢？

当产生了内存碎片，由于内存空间的断续，后续如果有新的对象进入老生代空间，而这个新对象又需要占用大量内存空间，那么抛除零散空间的老生代内存是无法提供满足条件的内存空间，这就意味着需要再一次进行垃圾回收直到这个新对象能进入内存，结果就是 —— 本轮垃圾回收提前出发，严重时会出现明显掉帧。

改进：后来也是针对这个缺点做了改进在 **标记-清除** 的基础上产生了 **标记-整理** 的新的垃圾回收策略，**标记整理** 会在老生代执行垃圾清除操作之前，将存活的对象统一移动至内存空间的一端，对另一端被标记为要清除对象进行垃圾清除操作，这样就有效避免了 **内存碎片**。

- PS：由于涉及知识点过多，部分细节未深讲，感兴趣可自行下去了解。
## goldEli 
 > commented 23 days ago 

任何垃圾回收机制都分为三个阶段：

1. 标记存活/废弃对象（live/dead objects）
2. 清理废弃对象
3. 整理碎片
 
所以为了让 V8 更快，那么就应该让这三个阶段用时尽可能短。

V8 设计了 generation 的堆结构，分为 young generation 和 old generation。

引擎开始执行 js 代码时，对象会进入 young generation，3次 GC 后，会把依然存活的对象移到 old generation。之后新创建的对象会进入 young genaeration，然后 3次 GC 后，依然存活的又会进入 old generation。如此往复。

这样的目的就是把经常活跃的对象隔离出去，因为在 old generation 的对象大概率不会被回收的。所以每次 GC 只用标记清理 young generation 的对象。而 old generation 的对象只有达到一定的占用率才会触发 GC。

相比每次 GC 对所有对象进行标记清理，这种方式大大减少了垃圾回收时间。

### Reference

[Trash talk: the Orinoco garbage collector](https://v8.dev/blog/trash-talk)